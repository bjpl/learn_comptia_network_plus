import { describe, it, expect, beforeEach } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import App from '../../../src/App';
import { useAppStore } from '../../../src/stores/appStore';
import { useProgressStore } from '../../../src/stores/progressStore';
import { act, renderHook } from '@testing-library/react';

describe('App Component', () => {
  beforeEach(() => {
    // Reset stores
    const { result: appResult } = renderHook(() => useAppStore());
    const { result: progressResult } = renderHook(() => useProgressStore());

    act(() => {
      appResult.current.setTheme('light');
      progressResult.current.resetProgress();
    });

    // Clear document classes
    document.documentElement.classList.remove('light', 'dark');
  });

  describe('Rendering', () => {
    it('should render without crashing', () => {
      expect(() => {
        render(<App />);
      }).not.toThrow();
    });

    it('should wrap content in React.StrictMode', () => {
      const { container } = render(<App />);
      expect(container).toBeDefined();
    });

    it('should render ThemeProvider', async () => {
      render(<App />);

      // Theme should be applied to document
      await waitFor(() => {
        expect(document.documentElement.classList.contains('light')).toBe(true);
      });
    });

    it('should render ProgressProvider', () => {
      // Providers are tested by checking if their context is available
      render(<App />);

      // If no errors are thrown, providers are working
      expect(true).toBe(true);
    });

    it('should render RouterProvider', async () => {
      render(<App />);

      // Router should load the app
      await waitFor(() => {
        expect(document.querySelector('body')).toBeDefined();
      });
    });
  });

  describe('Provider Hierarchy', () => {
    it('should nest providers correctly (Theme > Progress > Router)', () => {
      const { container } = render(<App />);

      // All providers should be initialized
      expect(container).toBeTruthy();
      expect(document.documentElement.classList.length).toBeGreaterThan(0);
    });

    it('should provide theme context to children', async () => {
      render(<App />);

      await waitFor(() => {
        expect(document.documentElement.classList.contains('light') ||
               document.documentElement.classList.contains('dark')).toBe(true);
      });
    });

    it('should provide progress context to children', () => {
      const { result } = renderHook(() => useProgressStore());
      render(<App />);

      // Progress store should be accessible
      expect(result.current.getOverallProgress()).toBeDefined();
    });
  });

  describe('Theme Integration', () => {
    it('should initialize with light theme', async () => {
      render(<App />);

      await waitFor(() => {
        expect(document.documentElement.classList.contains('light')).toBe(true);
      });
    });

    it('should respect stored theme preference', async () => {
      const { result } = renderHook(() => useAppStore());

      act(() => {
        result.current.setTheme('dark');
      });

      render(<App />);

      await waitFor(() => {
        expect(document.documentElement.classList.contains('dark')).toBe(true);
      });
    });

    it('should update document class when theme changes', async () => {
      const { result } = renderHook(() => useAppStore());

      render(<App />);

      act(() => {
        result.current.toggleTheme();
      });

      await waitFor(() => {
        expect(document.documentElement.classList.contains('dark')).toBe(true);
      });
    });
  });

  describe('Progress Integration', () => {
    it('should track component progress', () => {
      const { result } = renderHook(() => useProgressStore());

      render(<App />);

      act(() => {
        result.current.markComponentComplete('test-component', 85);
      });

      const progress = result.current.getComponentProgress('test-component');
      expect(progress?.completed).toBe(true);
      expect(progress?.score).toBe(85);
    });

    it('should calculate overall progress', () => {
      const { result } = renderHook(() => useProgressStore());

      render(<App />);

      act(() => {
        result.current.markComponentComplete('comp-1', 90);
        result.current.markComponentComplete('comp-2', 95);
      });

      const overall = result.current.getOverallProgress();
      expect(overall.totalCompleted).toBe(2);
      expect(overall.averageScore).toBeCloseTo(92.5, 1);
    });

    it('should persist progress across app remounts', () => {
      const { result } = renderHook(() => useProgressStore());

      act(() => {
        result.current.markComponentComplete('persist-test', 88);
      });

      const { unmount } = render(<App />);
      unmount();

      render(<App />);

      const progress = result.current.getComponentProgress('persist-test');
      expect(progress?.score).toBe(88);
    });
  });

  describe('Router Integration', () => {
    it('should initialize router', async () => {
      render(<App />);

      await waitFor(() => {
        // Router should be active (no errors thrown)
        expect(document.body).toBeDefined();
      });
    });

    it('should handle route changes', async () => {
      const { result } = renderHook(() => useAppStore());

      render(<App />);

      act(() => {
        result.current.setCurrentRoute('/osi/layer-builder');
      });

      expect(result.current.currentRoute).toBe('/osi/layer-builder');
    });
  });

  describe('CSS Import', () => {
    it('should import index.css styles', () => {
      // If the component renders without error, CSS is imported correctly
      expect(() => {
        render(<App />);
      }).not.toThrow();
    });
  });

  describe('Error Handling', () => {
    it('should handle provider initialization errors gracefully', () => {
      // App should not crash even if there are initialization issues
      expect(() => {
        render(<App />);
      }).not.toThrow();
    });

    it('should render with missing localStorage', () => {
      // Zustand persist should handle missing localStorage gracefully
      const originalLocalStorage = window.localStorage;

      Object.defineProperty(window, 'localStorage', {
        value: undefined,
        writable: true,
      });

      expect(() => {
        render(<App />);
      }).not.toThrow();

      // Restore localStorage
      Object.defineProperty(window, 'localStorage', {
        value: originalLocalStorage,
        writable: true,
      });
    });
  });

  describe('StrictMode', () => {
    it('should run effects twice in development (StrictMode behavior)', () => {
      let effectCount = 0;

      // Mock a component to track effect runs
      const originalUseEffect = React.useEffect;
      vi.spyOn(React, 'useEffect').mockImplementation((effect, deps) => {
        effectCount++;
        return originalUseEffect(effect, deps);
      });

      render(<App />);

      // In StrictMode, effects run twice in development
      expect(effectCount).toBeGreaterThan(0);

      vi.restoreAllMocks();
    });
  });

  describe('Performance', () => {
    it('should render within acceptable time', async () => {
      const startTime = performance.now();

      render(<App />);

      const endTime = performance.now();
      const renderTime = endTime - startTime;

      // Render should complete within 1 second
      expect(renderTime).toBeLessThan(1000);
    });

    it('should not cause memory leaks on unmount', () => {
      const { unmount } = render(<App />);

      expect(() => {
        unmount();
      }).not.toThrow();
    });
  });

  describe('Multiple Instances', () => {
    it('should handle multiple app instances gracefully', () => {
      const { unmount: unmount1 } = render(<App />);
      const { unmount: unmount2 } = render(<App />);

      expect(() => {
        unmount1();
        unmount2();
      }).not.toThrow();
    });

    it('should share state across app instances via stores', () => {
      const { result } = renderHook(() => useAppStore());

      render(<App />);

      act(() => {
        result.current.setTheme('dark');
      });

      // New instance should reflect shared state
      render(<App />);

      expect(result.current.theme).toBe('dark');
    });
  });
});
